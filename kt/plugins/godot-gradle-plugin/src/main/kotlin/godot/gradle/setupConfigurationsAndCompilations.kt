package godot.gradle

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import godot.entrygenerator.EntryGenerator
import godot.gradle.util.absolutePathFixedForWindows
import godot.gradle.util.mapOfNonNullValuesOf
import godot.utils.GodotBuildProperties
import org.gradle.api.Project
import org.gradle.api.tasks.Exec
import org.gradle.kotlin.dsl.creating
import org.gradle.kotlin.dsl.dependencies
import org.gradle.kotlin.dsl.getValue
import org.gradle.kotlin.dsl.getting
import org.gradle.kotlin.dsl.invoke
import org.gradle.kotlin.dsl.kotlin
import org.gradle.kotlin.dsl.named
import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension
import java.io.File

/**
 * Set's up all configurations and compilations needed for kotlin_jvm to work and defines proper task dependencies between them.
 *
 * ## Overview
 * General overview of what this function set's up to happen on each build the user performs on his code:
 * - Creates a `bootstrap.jar` which contains all glue code for the `cpp -> jvm -> cpp` communication.
 * This `bootstrap.jar` is loaded automatically at startup by the `cpp` side of the module
 * - Applies our kotlin compiler plugin to the `main` configuration and compilation to automatically add the kotlin_jvm dependencies to the users project and to generate the entry file.
 * - Creates a second compilation named `game` which inherits the `main` compilation and adds the generated entry file from the `main` compilation to compile it and create a `Shadow Jar (Fat Jar) including all dependencies.
 * - Uses the created `Shadow Jar` named `main.jar` together with the created `bootstrap.jar` at startup
 *
 * ## Why creating a second compilation
 * The second compilation named `game` is needed to add and compile the generated entry file into the resulting jar in one build cycle.
 *
 * When we generate the entry file, we are too late to add additional sources to the current compilation process.
 *
 * Thus we create a second compilation, which inherits the `main` compilation and add the generated entry file from the `main` compilation to it.
 *
 * Leveraging the incremental build capabilities the additional time needed to compile the exact same code again with just one file added (the entry file), the additional time needed is negligible.
 *
 * Another way would be to directly generate Kotlin IR (intermediate representation). Then we would be able to add the generated entry sources to the current compilation process and would not need to do a second compilation.
 *
 * We opted to not do this for maintainability as well as easier debugging for the user as the user can look at the generated entry file, set breakpoints and get a meaningful stacktrace in case of an error.
 *
 * We also not used a normal annotation processor to be able to use the full information the compiler has at compile time for the entry generation process. Again increasing maintainability.
 */
fun Project.setupConfigurationsAndCompilations(godotExtension: GodotExtension, jvm: KotlinJvmProjectExtension) {
    //bootstrap jar containing all glue code
    val bootstrap = configurations.create("bootstrap") {
        dependencies {
            add(name, kotlin("stdlib"))
            add(name, "com.utopia-rise:godot-library:${GodotBuildProperties.godotKotlinVersion}")
        }
    }
    val main = configurations.create("main").apply {
        extendsFrom(configurations.getByName("implementation"), configurations.getByName("runtimeOnly"))
        exclude(
            mapOfNonNullValuesOf(
                "group" to "org.jetbrains.kotlin",
                "module" to null
            )
        )
    }
    //game configuration extending main configuration -> needed for shadow jar task
    val gameConfiguration = configurations.create("game").apply {
        extendsFrom(main)
    }

    //add our dependencies to the main compilation -> convenience for the user
    val mainCompilation = jvm.target.compilations.getByName("main").apply {
        dependencies {
            compileOnly("com.utopia-rise:godot-library:${GodotBuildProperties.godotKotlinVersion}")
        }
    }
    //create a second compilation named `game` and add all sources and dependency of the `main` compilation. Additionally add the generated entry sources generated by the `main` compilation
    val gameCompilation = jvm.target.compilations.create("game").apply {
        defaultSourceSet {
            dependencies {
                implementation(mainCompilation.compileDependencyFiles + mainCompilation.output.classesDirs)
            }
            kotlin.srcDirs(project.buildDir.resolve("godot-entry"))
        }
    }

    tasks {
        val createBuildLock by creating {
            doFirst {
                val buildLockDir = getBuildLockDir(projectDir)
                println("DEBUG: $buildLockDir")
                File(buildLockDir, "buildLock.lock").createNewFile()
            }
        }

        val deleteBuildLock by creating {
            doLast {
                val buildLockDir = getBuildLockDir(projectDir)
                File(buildLockDir, "buildLock.lock").delete()
            }
        }

        val bootstrapJar by creating(ShadowJar::class) {
            archiveBaseName.set("godot-bootstrap")
            configurations.add(bootstrap)
            exclude("**/module-info.class") //for android support: excludes java 9+ module info which cannot be parsed by the dx tool

            dependsOn(createBuildLock)
        }

        val shadowJar = named<ShadowJar>("shadowJar") {
            archiveBaseName.set("main")
            archiveVersion.set("")
            archiveClassifier.set("")
            configurations.clear()
            exclude("**/module-info.class") //for android support: excludes java 9+ module info which cannot be parsed by the dx tool
            configurations.add(gameConfiguration)
            from(gameCompilation.output.classesDirs)

            dependencies {
                exclude(dependency("org.jetbrains.kotlin:kotlin-stdlib.*"))
                exclude(dependency("com.utopia-rise:godot-library:.*"))
            }

            dependsOn(createBuildLock)
        }

        /**
         * This task is mainly for the case if a source file is deleted and no other change has happened.
         * Then the main configuration does not get recompiled, thus the deletion of the obsolete entry file for that class
         * does not get triggered, leading to a compiler error.
         * This task deletes and regenerates the MainEntry file for each build without the need of a recompilation.
         */
        val cleanupEntryFiles by creating {
            group = "godot-kotlin-jvm"
            description = "Cleanup of old entry files. No need to run manually"
            doLast {
                EntryGenerator.deleteOldEntryFilesAndReGenerateMainEntryFile(
                    mainCompilation
                        .allKotlinSourceSets
                        .flatMap { kotlinSourceSet ->
                            kotlinSourceSet
                                .kotlin
                                .srcDirs
                                .map { it.absolutePathFixedForWindows }
                        },
                    project.buildDir.resolve("godot-entry").absolutePath
                )
            }
        }

        val checkDxToolAccessible by creating {
            group = "godot-kotlin-jvm"
            description = "Checks if the dx tool is accessible and executable. Needed for android builds only"

            doLast {
                try {
                    val result = exec {
                        workingDir = projectDir
                        isIgnoreExitValue = true

                        if (DefaultNativePlatform.getCurrentOperatingSystem().isWindows) {
                            commandLine("cmd", "/c", godotExtension.dxToolPath.get(), "--version")
                        } else {
                            commandLine(godotExtension.dxToolPath.get(), "--version")
                        }
                    }
                    if (result.exitValue != 0) {
                        throw IllegalArgumentException("dx tool not found! Make sure the dx tool is in you PATH variable or set \"dxToolPath\" to the absolute path of the dx tool. Normally the dx tool resides in <android-sdk-root>/build-tools/<version>/dx. For more information visit the docs. Provided path: ${godotExtension.dxToolPath.get()}") //TODO: add url once doc ist hosted
                    }
                } catch (e: Throwable) {
                    throw IllegalArgumentException("dx tool not found! Make sure the dx tool is in you PATH variable or set \"dxToolPath\" to the absolute path of the dx tool. Normally the dx tool resides in <android-sdk-root>/build-tools/<version>/dx. For more information visit the docs. Provided path: ${godotExtension.dxToolPath.get()}") //TODO: add url once doc ist hosted
                }
            }
        }

        val createGodotBootstrapDexJar by creating(Exec::class) {
            group = "godot-kotlin-jvm"
            description = "Converts the godot-bootstrap.jar to an android compatible version. Needed for android builds only"

            dependsOn(checkDxToolAccessible, shadowJar, bootstrapJar)
            val libsDir = project.buildDir.resolve("libs")
            val godotBootstrapJar = File(libsDir, "godot-bootstrap.jar")

            workingDir = libsDir
            if (DefaultNativePlatform.getCurrentOperatingSystem().isWindows) {
                commandLine("cmd", "/c", godotExtension.dxToolPath.get(), "--dex", "--output=\"godot-bootstrap-dex.jar\"", "\"${godotBootstrapJar.absolutePath}\"")
            } else {
                commandLine(godotExtension.dxToolPath.get(), "--dex", "--output=godot-bootstrap-dex.jar", godotBootstrapJar.absolutePath)
            }
        }

        val createMainDexJar by creating(Exec::class) {
            group = "godot-kotlin-jvm"
            description = "Converts the main.jar to an android compatible version. Needed for android builds only"

            dependsOn(checkDxToolAccessible, shadowJar, bootstrapJar)
            val libsDir = project.buildDir.resolve("libs")
            val mainJar = File(libsDir, "main.jar")

            workingDir = libsDir
            if (DefaultNativePlatform.getCurrentOperatingSystem().isWindows) {
                commandLine("cmd", "/c", godotExtension.dxToolPath.get(), "--dex", "--output=\"main-dex.jar\"", "\"${mainJar.absolutePath}\"")
            } else {
                commandLine(godotExtension.dxToolPath.get(), "--dex", "--output=main-dex.jar", mainJar.absolutePath)
            }
        }

        val build by getting {
            dependsOn(cleanupEntryFiles, bootstrapJar, shadowJar, createBuildLock)
            finalizedBy(deleteBuildLock)
            if(godotExtension.isAndroidExportEnabled.get()) {
                finalizedBy(createGodotBootstrapDexJar, createMainDexJar)
            }
        }

        val clean by getting {
            dependsOn(createBuildLock)
            finalizedBy(deleteBuildLock)
        }

        //let the main compilation compile task be finalized by the game compilation compile task to catch possible errors
        //which would only occur in the game compilation early (ex. errors in the entry file which is not compiled in the main compilation)
        mainCompilation.compileKotlinTask.finalizedBy(gameCompilation.compileKotlinTask)
    }
}

private fun getBuildLockDir(projectDir: File): File {
    val name = "${projectDir.name}_buildLockDir"  //keep the same in the Bootstrap class!
    val tmpDir = System.getProperty("java.io.tmpdir")
    val lockDir = File(tmpDir, name)

    return if (lockDir.exists() && lockDir.isDirectory) {
        lockDir
    } else {
        lockDir.delete()
        lockDir.mkdirs()
        lockDir
    }
}
