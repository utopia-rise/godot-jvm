package godot.gradle

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import godot.gradle.util.mapOfNonNullValuesOf
import godot.utils.GodotBuildProperties
import org.gradle.api.Project
import org.gradle.kotlin.dsl.*
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension

/**
 * Set's up all configurations and compilations needed for kotlin_jvm to work and defines proper task dependencies between them.
 *
 * ## Overview
 * General overview of what this function set's up to happen on each build the user performs on his code:
 * - Creates a `bootstrap.jar` which contains all glue code for the `cpp -> jvm -> cpp` communication.
 * This `bootstrap.jar` is loaded automatically at startup by the `cpp` side of the module
 * - Applies our kotlin compiler plugin to the `main` configuration and compilation to automatically add the kotlin_jvm dependencies to the users project and to generate the entry file.
 * - Creates a second compilation named `game` which inherits the `main` compilation and adds the generated entry file from the `main` compilation to compile it and create a `Shadow Jar (Fat Jar) including all dependencies.
 * - Uses the created `Shadow Jar` named `main.jar` together with the created `bootstrap.jar` at startup
 *
 * ## Why creating a second compilation
 * The second compilation named `game` is needed to add and compile the generated entry file into the resulting jar in one build cycle.
 *
 * When we generate the entry file, we are too late to add additional sources to the current compilation process.
 *
 * Thus we create a second compilation, which inherits the `main` compilation and add the generated entry file from the `main` compilation to it.
 *
 * Leveraging the incremental build capabilities the additional time needed to compile the exact same code again with just one file added (the entry file), the additional time needed is negligible.
 *
 * Another way would be to directly generate Kotlin IR (intermediate representation). Then we would be able to add the generated entry sources to the current compilation process and would not need to do a second compilation.
 *
 * We opted to not do this for maintainability as well as easier debugging for the user as the user can look at the generated entry file, set breakpoints and get a meaningful stacktrace in case of an error.
 *
 * We also not used a normal annotation processor to be able to use the full information the compiler has at compile time for the entry generation process. Again increasing maintainability.
 */
fun Project.setupConfigurationsAndCompilations(jvm: KotlinJvmProjectExtension, project: Project) {
    //bootstrap jar containing all glue code
    val bootstrap = configurations.create("bootstrap") {
        dependencies {
            add(name, kotlin("stdlib"))
            add(name, "com.utopia-rise:godot-library:${GodotBuildProperties.godotKotlinVersion}")
        }
    }
    val main = configurations.create("main").apply {
        extendsFrom(configurations.getByName("implementation"), configurations.getByName("runtimeOnly"))
        exclude(
            mapOfNonNullValuesOf(
                "group" to "org.jetbrains.kotlin",
                "module" to null
            )
        )
    }
    //game configuration extending main configuration -> needed for shadow jar task
    val gameConfiguration = configurations.create("game").apply {
        extendsFrom(main)
    }

    //add our dependencies to the main compilation -> convenience for the user
    val mainCompilation = jvm.target.compilations.getByName("main").apply {
        dependencies {
            compileOnly("com.utopia-rise:godot-library:${GodotBuildProperties.godotKotlinVersion}")
        }
    }
    //create a second compilation named `game` and add all sources and dependency of the `main` compilation. Additionally add the generated entry sources generated by the `main` compilation
    val gameCompilation = jvm.target.compilations.create("game").apply {
        defaultSourceSet {
            dependencies {
                implementation(mainCompilation.compileDependencyFiles + mainCompilation.output.classesDirs)
            }
            kotlin.srcDirs(project.buildDir.resolve("godot-entry"))
        }
    }

    tasks {
        val bootstrapJar by creating(ShadowJar::class) {
            archiveBaseName.set("godot-bootstrap")
            configurations.add(bootstrap)
        }

        val shadowJar = named<ShadowJar>("shadowJar") {
            archiveBaseName.set("main")
            archiveVersion.set("")
            archiveClassifier.set("")
            configurations.clear()
            configurations.add(gameConfiguration)
            from(gameCompilation.compileDependencyFiles + gameCompilation.output.classesDirs)
        }

        val build by getting {
            dependsOn(bootstrapJar, shadowJar)
        }

        //let the main compilation compile task be finalized by the game compilation compile task to catch possible errors
        //which would only occur in the game compilation early (ex. errors in the entry file which is not compiled in the main compilation)
        mainCompilation.compileKotlinTask.finalizedBy(gameCompilation.compileKotlinTask)
    }
}
