// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wire.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_wire_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_wire_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_wire_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_wire_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_wire_2eproto;
namespace wire {
class AABB;
class AABBDefaultTypeInternal;
extern AABBDefaultTypeInternal _AABB_default_instance_;
class Basis;
class BasisDefaultTypeInternal;
extern BasisDefaultTypeInternal _Basis_default_instance_;
class FuncArgs;
class FuncArgsDefaultTypeInternal;
extern FuncArgsDefaultTypeInternal _FuncArgs_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Plane;
class PlaneDefaultTypeInternal;
extern PlaneDefaultTypeInternal _Plane_default_instance_;
class Quat;
class QuatDefaultTypeInternal;
extern QuatDefaultTypeInternal _Quat_default_instance_;
class Rect2;
class Rect2DefaultTypeInternal;
extern Rect2DefaultTypeInternal _Rect2_default_instance_;
class ReturnValue;
class ReturnValueDefaultTypeInternal;
extern ReturnValueDefaultTypeInternal _ReturnValue_default_instance_;
class Transform;
class TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class Transform2D;
class Transform2DDefaultTypeInternal;
extern Transform2DDefaultTypeInternal _Transform2D_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class VariantArray;
class VariantArrayDefaultTypeInternal;
extern VariantArrayDefaultTypeInternal _VariantArray_default_instance_;
class Vector2;
class Vector2DefaultTypeInternal;
extern Vector2DefaultTypeInternal _Vector2_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace wire
PROTOBUF_NAMESPACE_OPEN
template<> ::wire::AABB* Arena::CreateMaybeMessage<::wire::AABB>(Arena*);
template<> ::wire::Basis* Arena::CreateMaybeMessage<::wire::Basis>(Arena*);
template<> ::wire::FuncArgs* Arena::CreateMaybeMessage<::wire::FuncArgs>(Arena*);
template<> ::wire::Object* Arena::CreateMaybeMessage<::wire::Object>(Arena*);
template<> ::wire::Plane* Arena::CreateMaybeMessage<::wire::Plane>(Arena*);
template<> ::wire::Quat* Arena::CreateMaybeMessage<::wire::Quat>(Arena*);
template<> ::wire::Rect2* Arena::CreateMaybeMessage<::wire::Rect2>(Arena*);
template<> ::wire::ReturnValue* Arena::CreateMaybeMessage<::wire::ReturnValue>(Arena*);
template<> ::wire::Transform* Arena::CreateMaybeMessage<::wire::Transform>(Arena*);
template<> ::wire::Transform2D* Arena::CreateMaybeMessage<::wire::Transform2D>(Arena*);
template<> ::wire::Value* Arena::CreateMaybeMessage<::wire::Value>(Arena*);
template<> ::wire::VariantArray* Arena::CreateMaybeMessage<::wire::VariantArray>(Arena*);
template<> ::wire::Vector2* Arena::CreateMaybeMessage<::wire::Vector2>(Arena*);
template<> ::wire::Vector3* Arena::CreateMaybeMessage<::wire::Vector3>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace wire {

// ===================================================================

class Vector2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Vector2) */ {
 public:
  inline Vector2() : Vector2(nullptr) {}
  virtual ~Vector2();

  Vector2(const Vector2& from);
  Vector2(Vector2&& from) noexcept
    : Vector2() {
    *this = ::std::move(from);
  }

  inline Vector2& operator=(const Vector2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2& operator=(Vector2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector2* internal_default_instance() {
    return reinterpret_cast<const Vector2*>(
               &_Vector2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector2& a, Vector2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector2* New() const final {
    return CreateMaybeMessage<Vector2>(nullptr);
  }

  Vector2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector2& from);
  void MergeFrom(const Vector2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Vector2";
  }
  protected:
  explicit Vector2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:wire.Vector2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class Rect2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Rect2) */ {
 public:
  inline Rect2() : Rect2(nullptr) {}
  virtual ~Rect2();

  Rect2(const Rect2& from);
  Rect2(Rect2&& from) noexcept
    : Rect2() {
    *this = ::std::move(from);
  }

  inline Rect2& operator=(const Rect2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rect2& operator=(Rect2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Rect2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rect2* internal_default_instance() {
    return reinterpret_cast<const Rect2*>(
               &_Rect2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Rect2& a, Rect2& b) {
    a.Swap(&b);
  }
  inline void Swap(Rect2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rect2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Rect2* New() const final {
    return CreateMaybeMessage<Rect2>(nullptr);
  }

  Rect2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Rect2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Rect2& from);
  void MergeFrom(const Rect2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rect2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Rect2";
  }
  protected:
  explicit Rect2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .wire.Vector2 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::wire::Vector2& position() const;
  ::wire::Vector2* release_position();
  ::wire::Vector2* mutable_position();
  void set_allocated_position(::wire::Vector2* position);
  private:
  const ::wire::Vector2& _internal_position() const;
  ::wire::Vector2* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::wire::Vector2* position);
  ::wire::Vector2* unsafe_arena_release_position();

  // .wire.Vector2 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::wire::Vector2& size() const;
  ::wire::Vector2* release_size();
  ::wire::Vector2* mutable_size();
  void set_allocated_size(::wire::Vector2* size);
  private:
  const ::wire::Vector2& _internal_size() const;
  ::wire::Vector2* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::wire::Vector2* size);
  ::wire::Vector2* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:wire.Rect2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::wire::Vector2* position_;
  ::wire::Vector2* size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class Vector3 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  virtual ~Vector3();

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const final {
    return CreateMaybeMessage<Vector3>(nullptr);
  }

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:wire.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class Transform2D PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Transform2D) */ {
 public:
  inline Transform2D() : Transform2D(nullptr) {}
  virtual ~Transform2D();

  Transform2D(const Transform2D& from);
  Transform2D(Transform2D&& from) noexcept
    : Transform2D() {
    *this = ::std::move(from);
  }

  inline Transform2D& operator=(const Transform2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform2D& operator=(Transform2D&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Transform2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transform2D* internal_default_instance() {
    return reinterpret_cast<const Transform2D*>(
               &_Transform2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Transform2D& a, Transform2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform2D* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transform2D* New() const final {
    return CreateMaybeMessage<Transform2D>(nullptr);
  }

  Transform2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transform2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Transform2D& from);
  void MergeFrom(const Transform2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transform2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Transform2D";
  }
  protected:
  explicit Transform2D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kOriginFieldNumber = 3,
  };
  // .wire.Vector2 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const ::wire::Vector2& x() const;
  ::wire::Vector2* release_x();
  ::wire::Vector2* mutable_x();
  void set_allocated_x(::wire::Vector2* x);
  private:
  const ::wire::Vector2& _internal_x() const;
  ::wire::Vector2* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      ::wire::Vector2* x);
  ::wire::Vector2* unsafe_arena_release_x();

  // .wire.Vector2 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const ::wire::Vector2& y() const;
  ::wire::Vector2* release_y();
  ::wire::Vector2* mutable_y();
  void set_allocated_y(::wire::Vector2* y);
  private:
  const ::wire::Vector2& _internal_y() const;
  ::wire::Vector2* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      ::wire::Vector2* y);
  ::wire::Vector2* unsafe_arena_release_y();

  // .wire.Vector2 origin = 3;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::wire::Vector2& origin() const;
  ::wire::Vector2* release_origin();
  ::wire::Vector2* mutable_origin();
  void set_allocated_origin(::wire::Vector2* origin);
  private:
  const ::wire::Vector2& _internal_origin() const;
  ::wire::Vector2* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::wire::Vector2* origin);
  ::wire::Vector2* unsafe_arena_release_origin();

  // @@protoc_insertion_point(class_scope:wire.Transform2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::wire::Vector2* x_;
  ::wire::Vector2* y_;
  ::wire::Vector2* origin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class Plane PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Plane) */ {
 public:
  inline Plane() : Plane(nullptr) {}
  virtual ~Plane();

  Plane(const Plane& from);
  Plane(Plane&& from) noexcept
    : Plane() {
    *this = ::std::move(from);
  }

  inline Plane& operator=(const Plane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plane& operator=(Plane&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Plane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Plane* internal_default_instance() {
    return reinterpret_cast<const Plane*>(
               &_Plane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Plane& a, Plane& b) {
    a.Swap(&b);
  }
  inline void Swap(Plane* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Plane* New() const final {
    return CreateMaybeMessage<Plane>(nullptr);
  }

  Plane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Plane>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Plane& from);
  void MergeFrom(const Plane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plane* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Plane";
  }
  protected:
  explicit Plane(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNormalFieldNumber = 1,
    kDFieldNumber = 2,
  };
  // .wire.Vector3 normal = 1;
  bool has_normal() const;
  private:
  bool _internal_has_normal() const;
  public:
  void clear_normal();
  const ::wire::Vector3& normal() const;
  ::wire::Vector3* release_normal();
  ::wire::Vector3* mutable_normal();
  void set_allocated_normal(::wire::Vector3* normal);
  private:
  const ::wire::Vector3& _internal_normal() const;
  ::wire::Vector3* _internal_mutable_normal();
  public:
  void unsafe_arena_set_allocated_normal(
      ::wire::Vector3* normal);
  ::wire::Vector3* unsafe_arena_release_normal();

  // float d = 2;
  void clear_d();
  float d() const;
  void set_d(float value);
  private:
  float _internal_d() const;
  void _internal_set_d(float value);
  public:

  // @@protoc_insertion_point(class_scope:wire.Plane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::wire::Vector3* normal_;
  float d_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class Quat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Quat) */ {
 public:
  inline Quat() : Quat(nullptr) {}
  virtual ~Quat();

  Quat(const Quat& from);
  Quat(Quat&& from) noexcept
    : Quat() {
    *this = ::std::move(from);
  }

  inline Quat& operator=(const Quat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quat& operator=(Quat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Quat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quat* internal_default_instance() {
    return reinterpret_cast<const Quat*>(
               &_Quat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Quat& a, Quat& b) {
    a.Swap(&b);
  }
  inline void Swap(Quat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quat* New() const final {
    return CreateMaybeMessage<Quat>(nullptr);
  }

  Quat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Quat& from);
  void MergeFrom(const Quat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Quat";
  }
  protected:
  explicit Quat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float w = 4;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:wire.Quat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  float w_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class AABB PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.AABB) */ {
 public:
  inline AABB() : AABB(nullptr) {}
  virtual ~AABB();

  AABB(const AABB& from);
  AABB(AABB&& from) noexcept
    : AABB() {
    *this = ::std::move(from);
  }

  inline AABB& operator=(const AABB& from) {
    CopyFrom(from);
    return *this;
  }
  inline AABB& operator=(AABB&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AABB& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AABB* internal_default_instance() {
    return reinterpret_cast<const AABB*>(
               &_AABB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AABB& a, AABB& b) {
    a.Swap(&b);
  }
  inline void Swap(AABB* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AABB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AABB* New() const final {
    return CreateMaybeMessage<AABB>(nullptr);
  }

  AABB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AABB>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AABB& from);
  void MergeFrom(const AABB& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AABB* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.AABB";
  }
  protected:
  explicit AABB(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .wire.Vector3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::wire::Vector3& position() const;
  ::wire::Vector3* release_position();
  ::wire::Vector3* mutable_position();
  void set_allocated_position(::wire::Vector3* position);
  private:
  const ::wire::Vector3& _internal_position() const;
  ::wire::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::wire::Vector3* position);
  ::wire::Vector3* unsafe_arena_release_position();

  // .wire.Vector3 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::wire::Vector3& size() const;
  ::wire::Vector3* release_size();
  ::wire::Vector3* mutable_size();
  void set_allocated_size(::wire::Vector3* size);
  private:
  const ::wire::Vector3& _internal_size() const;
  ::wire::Vector3* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::wire::Vector3* size);
  ::wire::Vector3* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:wire.AABB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::wire::Vector3* position_;
  ::wire::Vector3* size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class Basis PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Basis) */ {
 public:
  inline Basis() : Basis(nullptr) {}
  virtual ~Basis();

  Basis(const Basis& from);
  Basis(Basis&& from) noexcept
    : Basis() {
    *this = ::std::move(from);
  }

  inline Basis& operator=(const Basis& from) {
    CopyFrom(from);
    return *this;
  }
  inline Basis& operator=(Basis&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Basis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Basis* internal_default_instance() {
    return reinterpret_cast<const Basis*>(
               &_Basis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Basis& a, Basis& b) {
    a.Swap(&b);
  }
  inline void Swap(Basis* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Basis* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Basis* New() const final {
    return CreateMaybeMessage<Basis>(nullptr);
  }

  Basis* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Basis>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Basis& from);
  void MergeFrom(const Basis& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Basis* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Basis";
  }
  protected:
  explicit Basis(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .wire.Vector3 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const ::wire::Vector3& x() const;
  ::wire::Vector3* release_x();
  ::wire::Vector3* mutable_x();
  void set_allocated_x(::wire::Vector3* x);
  private:
  const ::wire::Vector3& _internal_x() const;
  ::wire::Vector3* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      ::wire::Vector3* x);
  ::wire::Vector3* unsafe_arena_release_x();

  // .wire.Vector3 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const ::wire::Vector3& y() const;
  ::wire::Vector3* release_y();
  ::wire::Vector3* mutable_y();
  void set_allocated_y(::wire::Vector3* y);
  private:
  const ::wire::Vector3& _internal_y() const;
  ::wire::Vector3* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      ::wire::Vector3* y);
  ::wire::Vector3* unsafe_arena_release_y();

  // .wire.Vector3 z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  const ::wire::Vector3& z() const;
  ::wire::Vector3* release_z();
  ::wire::Vector3* mutable_z();
  void set_allocated_z(::wire::Vector3* z);
  private:
  const ::wire::Vector3& _internal_z() const;
  ::wire::Vector3* _internal_mutable_z();
  public:
  void unsafe_arena_set_allocated_z(
      ::wire::Vector3* z);
  ::wire::Vector3* unsafe_arena_release_z();

  // @@protoc_insertion_point(class_scope:wire.Basis)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::wire::Vector3* x_;
  ::wire::Vector3* y_;
  ::wire::Vector3* z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class Transform PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  virtual ~Transform();

  Transform(const Transform& from);
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Transform& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transform* New() const final {
    return CreateMaybeMessage<Transform>(nullptr);
  }

  Transform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transform* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Transform";
  }
  protected:
  explicit Transform(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasisFieldNumber = 1,
    kOriginFieldNumber = 2,
  };
  // .wire.Basis basis = 1;
  bool has_basis() const;
  private:
  bool _internal_has_basis() const;
  public:
  void clear_basis();
  const ::wire::Basis& basis() const;
  ::wire::Basis* release_basis();
  ::wire::Basis* mutable_basis();
  void set_allocated_basis(::wire::Basis* basis);
  private:
  const ::wire::Basis& _internal_basis() const;
  ::wire::Basis* _internal_mutable_basis();
  public:
  void unsafe_arena_set_allocated_basis(
      ::wire::Basis* basis);
  ::wire::Basis* unsafe_arena_release_basis();

  // .wire.Vector3 origin = 2;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::wire::Vector3& origin() const;
  ::wire::Vector3* release_origin();
  ::wire::Vector3* mutable_origin();
  void set_allocated_origin(::wire::Vector3* origin);
  private:
  const ::wire::Vector3& _internal_origin() const;
  ::wire::Vector3* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::wire::Vector3* origin);
  ::wire::Vector3* unsafe_arena_release_origin();

  // @@protoc_insertion_point(class_scope:wire.Transform)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::wire::Basis* basis_;
  ::wire::Vector3* origin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class VariantArray PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.VariantArray) */ {
 public:
  inline VariantArray() : VariantArray(nullptr) {}
  virtual ~VariantArray();

  VariantArray(const VariantArray& from);
  VariantArray(VariantArray&& from) noexcept
    : VariantArray() {
    *this = ::std::move(from);
  }

  inline VariantArray& operator=(const VariantArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline VariantArray& operator=(VariantArray&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VariantArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VariantArray* internal_default_instance() {
    return reinterpret_cast<const VariantArray*>(
               &_VariantArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VariantArray& a, VariantArray& b) {
    a.Swap(&b);
  }
  inline void Swap(VariantArray* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VariantArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VariantArray* New() const final {
    return CreateMaybeMessage<VariantArray>(nullptr);
  }

  VariantArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VariantArray>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VariantArray& from);
  void MergeFrom(const VariantArray& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VariantArray* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.VariantArray";
  }
  protected:
  explicit VariantArray(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:wire.VariantArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class Object PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  virtual ~Object();

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return CreateMaybeMessage<Object>(nullptr);
  }

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtrFieldNumber = 1,
    kEngineConstructorIndexFieldNumber = 2,
    kIsRefFieldNumber = 3,
    kInstanceIdFieldNumber = 4,
  };
  // fixed64 ptr = 1;
  void clear_ptr();
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr() const;
  void set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ptr() const;
  void _internal_set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 engine_constructor_index = 2;
  void clear_engine_constructor_index();
  ::PROTOBUF_NAMESPACE_ID::int32 engine_constructor_index() const;
  void set_engine_constructor_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_engine_constructor_index() const;
  void _internal_set_engine_constructor_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_ref = 3;
  void clear_is_ref();
  bool is_ref() const;
  void set_is_ref(bool value);
  private:
  bool _internal_is_ref() const;
  void _internal_set_is_ref(bool value);
  public:

  // uint64 instance_id = 4;
  void clear_instance_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 instance_id() const;
  void set_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_instance_id() const;
  void _internal_set_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:wire.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr_;
  ::PROTOBUF_NAMESPACE_ID::int32 engine_constructor_index_;
  bool is_ref_;
  ::PROTOBUF_NAMESPACE_ID::uint64 instance_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class Value PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  virtual ~Value();

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Value& default_instance();

  enum TypeCase {
    kNilValue = 1,
    kBoolValue = 2,
    kLongValue = 3,
    kRealValue = 4,
    kStringValue = 5,
    kVector2Value = 6,
    kRect2Value = 7,
    kVector3Value = 8,
    kTransform2DValue = 9,
    kPlaneValue = 10,
    kQuatValue = 11,
    kAabbValue = 12,
    kBasisValue = 13,
    kTransformValue = 14,
    kVariantArrayValue = 15,
    kObjectValue = 16,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return CreateMaybeMessage<Value>(nullptr);
  }

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNilValueFieldNumber = 1,
    kBoolValueFieldNumber = 2,
    kLongValueFieldNumber = 3,
    kRealValueFieldNumber = 4,
    kStringValueFieldNumber = 5,
    kVector2ValueFieldNumber = 6,
    kRect2ValueFieldNumber = 7,
    kVector3ValueFieldNumber = 8,
    kTransform2DValueFieldNumber = 9,
    kPlaneValueFieldNumber = 10,
    kQuatValueFieldNumber = 11,
    kAabbValueFieldNumber = 12,
    kBasisValueFieldNumber = 13,
    kTransformValueFieldNumber = 14,
    kVariantArrayValueFieldNumber = 15,
    kObjectValueFieldNumber = 16,
  };
  // int32 nil_value = 1;
  private:
  bool _internal_has_nil_value() const;
  public:
  void clear_nil_value();
  ::PROTOBUF_NAMESPACE_ID::int32 nil_value() const;
  void set_nil_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nil_value() const;
  void _internal_set_nil_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool bool_value = 2;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  // int64 long_value = 3;
  private:
  bool _internal_has_long_value() const;
  public:
  void clear_long_value();
  ::PROTOBUF_NAMESPACE_ID::int64 long_value() const;
  void set_long_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_long_value() const;
  void _internal_set_long_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double real_value = 4;
  private:
  bool _internal_has_real_value() const;
  public:
  void clear_real_value();
  double real_value() const;
  void set_real_value(double value);
  private:
  double _internal_real_value() const;
  void _internal_set_real_value(double value);
  public:

  // string string_value = 5;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  void set_string_value(const std::string& value);
  void set_string_value(std::string&& value);
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  std::string* mutable_string_value();
  std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // .wire.Vector2 vector2_value = 6;
  bool has_vector2_value() const;
  private:
  bool _internal_has_vector2_value() const;
  public:
  void clear_vector2_value();
  const ::wire::Vector2& vector2_value() const;
  ::wire::Vector2* release_vector2_value();
  ::wire::Vector2* mutable_vector2_value();
  void set_allocated_vector2_value(::wire::Vector2* vector2_value);
  private:
  const ::wire::Vector2& _internal_vector2_value() const;
  ::wire::Vector2* _internal_mutable_vector2_value();
  public:
  void unsafe_arena_set_allocated_vector2_value(
      ::wire::Vector2* vector2_value);
  ::wire::Vector2* unsafe_arena_release_vector2_value();

  // .wire.Rect2 rect2_value = 7;
  bool has_rect2_value() const;
  private:
  bool _internal_has_rect2_value() const;
  public:
  void clear_rect2_value();
  const ::wire::Rect2& rect2_value() const;
  ::wire::Rect2* release_rect2_value();
  ::wire::Rect2* mutable_rect2_value();
  void set_allocated_rect2_value(::wire::Rect2* rect2_value);
  private:
  const ::wire::Rect2& _internal_rect2_value() const;
  ::wire::Rect2* _internal_mutable_rect2_value();
  public:
  void unsafe_arena_set_allocated_rect2_value(
      ::wire::Rect2* rect2_value);
  ::wire::Rect2* unsafe_arena_release_rect2_value();

  // .wire.Vector3 vector3_value = 8;
  bool has_vector3_value() const;
  private:
  bool _internal_has_vector3_value() const;
  public:
  void clear_vector3_value();
  const ::wire::Vector3& vector3_value() const;
  ::wire::Vector3* release_vector3_value();
  ::wire::Vector3* mutable_vector3_value();
  void set_allocated_vector3_value(::wire::Vector3* vector3_value);
  private:
  const ::wire::Vector3& _internal_vector3_value() const;
  ::wire::Vector3* _internal_mutable_vector3_value();
  public:
  void unsafe_arena_set_allocated_vector3_value(
      ::wire::Vector3* vector3_value);
  ::wire::Vector3* unsafe_arena_release_vector3_value();

  // .wire.Transform2D transform2D_value = 9;
  bool has_transform2d_value() const;
  private:
  bool _internal_has_transform2d_value() const;
  public:
  void clear_transform2d_value();
  const ::wire::Transform2D& transform2d_value() const;
  ::wire::Transform2D* release_transform2d_value();
  ::wire::Transform2D* mutable_transform2d_value();
  void set_allocated_transform2d_value(::wire::Transform2D* transform2d_value);
  private:
  const ::wire::Transform2D& _internal_transform2d_value() const;
  ::wire::Transform2D* _internal_mutable_transform2d_value();
  public:
  void unsafe_arena_set_allocated_transform2d_value(
      ::wire::Transform2D* transform2d_value);
  ::wire::Transform2D* unsafe_arena_release_transform2d_value();

  // .wire.Plane plane_value = 10;
  bool has_plane_value() const;
  private:
  bool _internal_has_plane_value() const;
  public:
  void clear_plane_value();
  const ::wire::Plane& plane_value() const;
  ::wire::Plane* release_plane_value();
  ::wire::Plane* mutable_plane_value();
  void set_allocated_plane_value(::wire::Plane* plane_value);
  private:
  const ::wire::Plane& _internal_plane_value() const;
  ::wire::Plane* _internal_mutable_plane_value();
  public:
  void unsafe_arena_set_allocated_plane_value(
      ::wire::Plane* plane_value);
  ::wire::Plane* unsafe_arena_release_plane_value();

  // .wire.Quat quat_value = 11;
  bool has_quat_value() const;
  private:
  bool _internal_has_quat_value() const;
  public:
  void clear_quat_value();
  const ::wire::Quat& quat_value() const;
  ::wire::Quat* release_quat_value();
  ::wire::Quat* mutable_quat_value();
  void set_allocated_quat_value(::wire::Quat* quat_value);
  private:
  const ::wire::Quat& _internal_quat_value() const;
  ::wire::Quat* _internal_mutable_quat_value();
  public:
  void unsafe_arena_set_allocated_quat_value(
      ::wire::Quat* quat_value);
  ::wire::Quat* unsafe_arena_release_quat_value();

  // .wire.AABB aabb_value = 12;
  bool has_aabb_value() const;
  private:
  bool _internal_has_aabb_value() const;
  public:
  void clear_aabb_value();
  const ::wire::AABB& aabb_value() const;
  ::wire::AABB* release_aabb_value();
  ::wire::AABB* mutable_aabb_value();
  void set_allocated_aabb_value(::wire::AABB* aabb_value);
  private:
  const ::wire::AABB& _internal_aabb_value() const;
  ::wire::AABB* _internal_mutable_aabb_value();
  public:
  void unsafe_arena_set_allocated_aabb_value(
      ::wire::AABB* aabb_value);
  ::wire::AABB* unsafe_arena_release_aabb_value();

  // .wire.Basis basis_value = 13;
  bool has_basis_value() const;
  private:
  bool _internal_has_basis_value() const;
  public:
  void clear_basis_value();
  const ::wire::Basis& basis_value() const;
  ::wire::Basis* release_basis_value();
  ::wire::Basis* mutable_basis_value();
  void set_allocated_basis_value(::wire::Basis* basis_value);
  private:
  const ::wire::Basis& _internal_basis_value() const;
  ::wire::Basis* _internal_mutable_basis_value();
  public:
  void unsafe_arena_set_allocated_basis_value(
      ::wire::Basis* basis_value);
  ::wire::Basis* unsafe_arena_release_basis_value();

  // .wire.Transform transform_value = 14;
  bool has_transform_value() const;
  private:
  bool _internal_has_transform_value() const;
  public:
  void clear_transform_value();
  const ::wire::Transform& transform_value() const;
  ::wire::Transform* release_transform_value();
  ::wire::Transform* mutable_transform_value();
  void set_allocated_transform_value(::wire::Transform* transform_value);
  private:
  const ::wire::Transform& _internal_transform_value() const;
  ::wire::Transform* _internal_mutable_transform_value();
  public:
  void unsafe_arena_set_allocated_transform_value(
      ::wire::Transform* transform_value);
  ::wire::Transform* unsafe_arena_release_transform_value();

  // .wire.VariantArray variant_array_value = 15;
  bool has_variant_array_value() const;
  private:
  bool _internal_has_variant_array_value() const;
  public:
  void clear_variant_array_value();
  const ::wire::VariantArray& variant_array_value() const;
  ::wire::VariantArray* release_variant_array_value();
  ::wire::VariantArray* mutable_variant_array_value();
  void set_allocated_variant_array_value(::wire::VariantArray* variant_array_value);
  private:
  const ::wire::VariantArray& _internal_variant_array_value() const;
  ::wire::VariantArray* _internal_mutable_variant_array_value();
  public:
  void unsafe_arena_set_allocated_variant_array_value(
      ::wire::VariantArray* variant_array_value);
  ::wire::VariantArray* unsafe_arena_release_variant_array_value();

  // .wire.Object object_value = 16;
  bool has_object_value() const;
  private:
  bool _internal_has_object_value() const;
  public:
  void clear_object_value();
  const ::wire::Object& object_value() const;
  ::wire::Object* release_object_value();
  ::wire::Object* mutable_object_value();
  void set_allocated_object_value(::wire::Object* object_value);
  private:
  const ::wire::Object& _internal_object_value() const;
  ::wire::Object* _internal_mutable_object_value();
  public:
  void unsafe_arena_set_allocated_object_value(
      ::wire::Object* object_value);
  ::wire::Object* unsafe_arena_release_object_value();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:wire.Value)
 private:
  class _Internal;
  void set_has_nil_value();
  void set_has_bool_value();
  void set_has_long_value();
  void set_has_real_value();
  void set_has_string_value();
  void set_has_vector2_value();
  void set_has_rect2_value();
  void set_has_vector3_value();
  void set_has_transform2d_value();
  void set_has_plane_value();
  void set_has_quat_value();
  void set_has_aabb_value();
  void set_has_basis_value();
  void set_has_transform_value();
  void set_has_variant_array_value();
  void set_has_object_value();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    TypeUnion() {}
    ::PROTOBUF_NAMESPACE_ID::int32 nil_value_;
    bool bool_value_;
    ::PROTOBUF_NAMESPACE_ID::int64 long_value_;
    double real_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    ::wire::Vector2* vector2_value_;
    ::wire::Rect2* rect2_value_;
    ::wire::Vector3* vector3_value_;
    ::wire::Transform2D* transform2d_value_;
    ::wire::Plane* plane_value_;
    ::wire::Quat* quat_value_;
    ::wire::AABB* aabb_value_;
    ::wire::Basis* basis_value_;
    ::wire::Transform* transform_value_;
    ::wire::VariantArray* variant_array_value_;
    ::wire::Object* object_value_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class ReturnValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.ReturnValue) */ {
 public:
  inline ReturnValue() : ReturnValue(nullptr) {}
  virtual ~ReturnValue();

  ReturnValue(const ReturnValue& from);
  ReturnValue(ReturnValue&& from) noexcept
    : ReturnValue() {
    *this = ::std::move(from);
  }

  inline ReturnValue& operator=(const ReturnValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReturnValue& operator=(ReturnValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReturnValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReturnValue* internal_default_instance() {
    return reinterpret_cast<const ReturnValue*>(
               &_ReturnValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ReturnValue& a, ReturnValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ReturnValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReturnValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReturnValue* New() const final {
    return CreateMaybeMessage<ReturnValue>(nullptr);
  }

  ReturnValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReturnValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReturnValue& from);
  void MergeFrom(const ReturnValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReturnValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.ReturnValue";
  }
  protected:
  explicit ReturnValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .wire.Value data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::wire::Value& data() const;
  ::wire::Value* release_data();
  ::wire::Value* mutable_data();
  void set_allocated_data(::wire::Value* data);
  private:
  const ::wire::Value& _internal_data() const;
  ::wire::Value* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::wire::Value* data);
  ::wire::Value* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:wire.ReturnValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::wire::Value* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// -------------------------------------------------------------------

class FuncArgs PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:wire.FuncArgs) */ {
 public:
  inline FuncArgs() : FuncArgs(nullptr) {}
  virtual ~FuncArgs();

  FuncArgs(const FuncArgs& from);
  FuncArgs(FuncArgs&& from) noexcept
    : FuncArgs() {
    *this = ::std::move(from);
  }

  inline FuncArgs& operator=(const FuncArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline FuncArgs& operator=(FuncArgs&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FuncArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FuncArgs* internal_default_instance() {
    return reinterpret_cast<const FuncArgs*>(
               &_FuncArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FuncArgs& a, FuncArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(FuncArgs* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FuncArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FuncArgs* New() const final {
    return CreateMaybeMessage<FuncArgs>(nullptr);
  }

  FuncArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FuncArgs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FuncArgs& from);
  void MergeFrom(const FuncArgs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FuncArgs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "wire.FuncArgs";
  }
  protected:
  explicit FuncArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wire_2eproto);
    return ::descriptor_table_wire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
  };
  // repeated .wire.Value args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::wire::Value* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::wire::Value >*
      mutable_args();
  private:
  const ::wire::Value& _internal_args(int index) const;
  ::wire::Value* _internal_add_args();
  public:
  const ::wire::Value& args(int index) const;
  ::wire::Value* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::wire::Value >&
      args() const;

  // @@protoc_insertion_point(class_scope:wire.FuncArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::wire::Value > args_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_wire_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector2

// float x = 1;
inline void Vector2::clear_x() {
  x_ = 0;
}
inline float Vector2::_internal_x() const {
  return x_;
}
inline float Vector2::x() const {
  // @@protoc_insertion_point(field_get:wire.Vector2.x)
  return _internal_x();
}
inline void Vector2::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vector2::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:wire.Vector2.x)
}

// float y = 2;
inline void Vector2::clear_y() {
  y_ = 0;
}
inline float Vector2::_internal_y() const {
  return y_;
}
inline float Vector2::y() const {
  // @@protoc_insertion_point(field_get:wire.Vector2.y)
  return _internal_y();
}
inline void Vector2::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vector2::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:wire.Vector2.y)
}

// -------------------------------------------------------------------

// Rect2

// .wire.Vector2 position = 1;
inline bool Rect2::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Rect2::has_position() const {
  return _internal_has_position();
}
inline void Rect2::clear_position() {
  if (GetArena() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::wire::Vector2& Rect2::_internal_position() const {
  const ::wire::Vector2* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector2*>(
      &::wire::_Vector2_default_instance_);
}
inline const ::wire::Vector2& Rect2::position() const {
  // @@protoc_insertion_point(field_get:wire.Rect2.position)
  return _internal_position();
}
inline void Rect2::unsafe_arena_set_allocated_position(
    ::wire::Vector2* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Rect2.position)
}
inline ::wire::Vector2* Rect2::release_position() {
  
  ::wire::Vector2* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector2* Rect2::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:wire.Rect2.position)
  
  ::wire::Vector2* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::wire::Vector2* Rect2::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector2>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::wire::Vector2* Rect2::mutable_position() {
  // @@protoc_insertion_point(field_mutable:wire.Rect2.position)
  return _internal_mutable_position();
}
inline void Rect2::set_allocated_position(::wire::Vector2* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:wire.Rect2.position)
}

// .wire.Vector2 size = 2;
inline bool Rect2::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Rect2::has_size() const {
  return _internal_has_size();
}
inline void Rect2::clear_size() {
  if (GetArena() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::wire::Vector2& Rect2::_internal_size() const {
  const ::wire::Vector2* p = size_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector2*>(
      &::wire::_Vector2_default_instance_);
}
inline const ::wire::Vector2& Rect2::size() const {
  // @@protoc_insertion_point(field_get:wire.Rect2.size)
  return _internal_size();
}
inline void Rect2::unsafe_arena_set_allocated_size(
    ::wire::Vector2* size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Rect2.size)
}
inline ::wire::Vector2* Rect2::release_size() {
  
  ::wire::Vector2* temp = size_;
  size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector2* Rect2::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:wire.Rect2.size)
  
  ::wire::Vector2* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::wire::Vector2* Rect2::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector2>(GetArena());
    size_ = p;
  }
  return size_;
}
inline ::wire::Vector2* Rect2::mutable_size() {
  // @@protoc_insertion_point(field_mutable:wire.Rect2.size)
  return _internal_mutable_size();
}
inline void Rect2::set_allocated_size(::wire::Vector2* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:wire.Rect2.size)
}

// -------------------------------------------------------------------

// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline float Vector3::_internal_x() const {
  return x_;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:wire.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:wire.Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline float Vector3::_internal_y() const {
  return y_;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:wire.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:wire.Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline float Vector3::_internal_z() const {
  return z_;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:wire.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:wire.Vector3.z)
}

// -------------------------------------------------------------------

// Transform2D

// .wire.Vector2 x = 1;
inline bool Transform2D::_internal_has_x() const {
  return this != internal_default_instance() && x_ != nullptr;
}
inline bool Transform2D::has_x() const {
  return _internal_has_x();
}
inline void Transform2D::clear_x() {
  if (GetArena() == nullptr && x_ != nullptr) {
    delete x_;
  }
  x_ = nullptr;
}
inline const ::wire::Vector2& Transform2D::_internal_x() const {
  const ::wire::Vector2* p = x_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector2*>(
      &::wire::_Vector2_default_instance_);
}
inline const ::wire::Vector2& Transform2D::x() const {
  // @@protoc_insertion_point(field_get:wire.Transform2D.x)
  return _internal_x();
}
inline void Transform2D::unsafe_arena_set_allocated_x(
    ::wire::Vector2* x) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  x_ = x;
  if (x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Transform2D.x)
}
inline ::wire::Vector2* Transform2D::release_x() {
  
  ::wire::Vector2* temp = x_;
  x_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector2* Transform2D::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:wire.Transform2D.x)
  
  ::wire::Vector2* temp = x_;
  x_ = nullptr;
  return temp;
}
inline ::wire::Vector2* Transform2D::_internal_mutable_x() {
  
  if (x_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector2>(GetArena());
    x_ = p;
  }
  return x_;
}
inline ::wire::Vector2* Transform2D::mutable_x() {
  // @@protoc_insertion_point(field_mutable:wire.Transform2D.x)
  return _internal_mutable_x();
}
inline void Transform2D::set_allocated_x(::wire::Vector2* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete x_;
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(x);
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:wire.Transform2D.x)
}

// .wire.Vector2 y = 2;
inline bool Transform2D::_internal_has_y() const {
  return this != internal_default_instance() && y_ != nullptr;
}
inline bool Transform2D::has_y() const {
  return _internal_has_y();
}
inline void Transform2D::clear_y() {
  if (GetArena() == nullptr && y_ != nullptr) {
    delete y_;
  }
  y_ = nullptr;
}
inline const ::wire::Vector2& Transform2D::_internal_y() const {
  const ::wire::Vector2* p = y_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector2*>(
      &::wire::_Vector2_default_instance_);
}
inline const ::wire::Vector2& Transform2D::y() const {
  // @@protoc_insertion_point(field_get:wire.Transform2D.y)
  return _internal_y();
}
inline void Transform2D::unsafe_arena_set_allocated_y(
    ::wire::Vector2* y) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Transform2D.y)
}
inline ::wire::Vector2* Transform2D::release_y() {
  
  ::wire::Vector2* temp = y_;
  y_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector2* Transform2D::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:wire.Transform2D.y)
  
  ::wire::Vector2* temp = y_;
  y_ = nullptr;
  return temp;
}
inline ::wire::Vector2* Transform2D::_internal_mutable_y() {
  
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector2>(GetArena());
    y_ = p;
  }
  return y_;
}
inline ::wire::Vector2* Transform2D::mutable_y() {
  // @@protoc_insertion_point(field_mutable:wire.Transform2D.y)
  return _internal_mutable_y();
}
inline void Transform2D::set_allocated_y(::wire::Vector2* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete y_;
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(y);
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:wire.Transform2D.y)
}

// .wire.Vector2 origin = 3;
inline bool Transform2D::_internal_has_origin() const {
  return this != internal_default_instance() && origin_ != nullptr;
}
inline bool Transform2D::has_origin() const {
  return _internal_has_origin();
}
inline void Transform2D::clear_origin() {
  if (GetArena() == nullptr && origin_ != nullptr) {
    delete origin_;
  }
  origin_ = nullptr;
}
inline const ::wire::Vector2& Transform2D::_internal_origin() const {
  const ::wire::Vector2* p = origin_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector2*>(
      &::wire::_Vector2_default_instance_);
}
inline const ::wire::Vector2& Transform2D::origin() const {
  // @@protoc_insertion_point(field_get:wire.Transform2D.origin)
  return _internal_origin();
}
inline void Transform2D::unsafe_arena_set_allocated_origin(
    ::wire::Vector2* origin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(origin_);
  }
  origin_ = origin;
  if (origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Transform2D.origin)
}
inline ::wire::Vector2* Transform2D::release_origin() {
  
  ::wire::Vector2* temp = origin_;
  origin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector2* Transform2D::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:wire.Transform2D.origin)
  
  ::wire::Vector2* temp = origin_;
  origin_ = nullptr;
  return temp;
}
inline ::wire::Vector2* Transform2D::_internal_mutable_origin() {
  
  if (origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector2>(GetArena());
    origin_ = p;
  }
  return origin_;
}
inline ::wire::Vector2* Transform2D::mutable_origin() {
  // @@protoc_insertion_point(field_mutable:wire.Transform2D.origin)
  return _internal_mutable_origin();
}
inline void Transform2D::set_allocated_origin(::wire::Vector2* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(origin);
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    
  } else {
    
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:wire.Transform2D.origin)
}

// -------------------------------------------------------------------

// Plane

// .wire.Vector3 normal = 1;
inline bool Plane::_internal_has_normal() const {
  return this != internal_default_instance() && normal_ != nullptr;
}
inline bool Plane::has_normal() const {
  return _internal_has_normal();
}
inline void Plane::clear_normal() {
  if (GetArena() == nullptr && normal_ != nullptr) {
    delete normal_;
  }
  normal_ = nullptr;
}
inline const ::wire::Vector3& Plane::_internal_normal() const {
  const ::wire::Vector3* p = normal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector3*>(
      &::wire::_Vector3_default_instance_);
}
inline const ::wire::Vector3& Plane::normal() const {
  // @@protoc_insertion_point(field_get:wire.Plane.normal)
  return _internal_normal();
}
inline void Plane::unsafe_arena_set_allocated_normal(
    ::wire::Vector3* normal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(normal_);
  }
  normal_ = normal;
  if (normal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Plane.normal)
}
inline ::wire::Vector3* Plane::release_normal() {
  
  ::wire::Vector3* temp = normal_;
  normal_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector3* Plane::unsafe_arena_release_normal() {
  // @@protoc_insertion_point(field_release:wire.Plane.normal)
  
  ::wire::Vector3* temp = normal_;
  normal_ = nullptr;
  return temp;
}
inline ::wire::Vector3* Plane::_internal_mutable_normal() {
  
  if (normal_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector3>(GetArena());
    normal_ = p;
  }
  return normal_;
}
inline ::wire::Vector3* Plane::mutable_normal() {
  // @@protoc_insertion_point(field_mutable:wire.Plane.normal)
  return _internal_mutable_normal();
}
inline void Plane::set_allocated_normal(::wire::Vector3* normal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete normal_;
  }
  if (normal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(normal);
    if (message_arena != submessage_arena) {
      normal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    
  } else {
    
  }
  normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:wire.Plane.normal)
}

// float d = 2;
inline void Plane::clear_d() {
  d_ = 0;
}
inline float Plane::_internal_d() const {
  return d_;
}
inline float Plane::d() const {
  // @@protoc_insertion_point(field_get:wire.Plane.d)
  return _internal_d();
}
inline void Plane::_internal_set_d(float value) {
  
  d_ = value;
}
inline void Plane::set_d(float value) {
  _internal_set_d(value);
  // @@protoc_insertion_point(field_set:wire.Plane.d)
}

// -------------------------------------------------------------------

// Quat

// float x = 1;
inline void Quat::clear_x() {
  x_ = 0;
}
inline float Quat::_internal_x() const {
  return x_;
}
inline float Quat::x() const {
  // @@protoc_insertion_point(field_get:wire.Quat.x)
  return _internal_x();
}
inline void Quat::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Quat::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:wire.Quat.x)
}

// float y = 2;
inline void Quat::clear_y() {
  y_ = 0;
}
inline float Quat::_internal_y() const {
  return y_;
}
inline float Quat::y() const {
  // @@protoc_insertion_point(field_get:wire.Quat.y)
  return _internal_y();
}
inline void Quat::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Quat::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:wire.Quat.y)
}

// float z = 3;
inline void Quat::clear_z() {
  z_ = 0;
}
inline float Quat::_internal_z() const {
  return z_;
}
inline float Quat::z() const {
  // @@protoc_insertion_point(field_get:wire.Quat.z)
  return _internal_z();
}
inline void Quat::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Quat::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:wire.Quat.z)
}

// float w = 4;
inline void Quat::clear_w() {
  w_ = 0;
}
inline float Quat::_internal_w() const {
  return w_;
}
inline float Quat::w() const {
  // @@protoc_insertion_point(field_get:wire.Quat.w)
  return _internal_w();
}
inline void Quat::_internal_set_w(float value) {
  
  w_ = value;
}
inline void Quat::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:wire.Quat.w)
}

// -------------------------------------------------------------------

// AABB

// .wire.Vector3 position = 1;
inline bool AABB::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool AABB::has_position() const {
  return _internal_has_position();
}
inline void AABB::clear_position() {
  if (GetArena() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::wire::Vector3& AABB::_internal_position() const {
  const ::wire::Vector3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector3*>(
      &::wire::_Vector3_default_instance_);
}
inline const ::wire::Vector3& AABB::position() const {
  // @@protoc_insertion_point(field_get:wire.AABB.position)
  return _internal_position();
}
inline void AABB::unsafe_arena_set_allocated_position(
    ::wire::Vector3* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.AABB.position)
}
inline ::wire::Vector3* AABB::release_position() {
  
  ::wire::Vector3* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector3* AABB::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:wire.AABB.position)
  
  ::wire::Vector3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::wire::Vector3* AABB::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector3>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::wire::Vector3* AABB::mutable_position() {
  // @@protoc_insertion_point(field_mutable:wire.AABB.position)
  return _internal_mutable_position();
}
inline void AABB::set_allocated_position(::wire::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:wire.AABB.position)
}

// .wire.Vector3 size = 2;
inline bool AABB::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool AABB::has_size() const {
  return _internal_has_size();
}
inline void AABB::clear_size() {
  if (GetArena() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::wire::Vector3& AABB::_internal_size() const {
  const ::wire::Vector3* p = size_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector3*>(
      &::wire::_Vector3_default_instance_);
}
inline const ::wire::Vector3& AABB::size() const {
  // @@protoc_insertion_point(field_get:wire.AABB.size)
  return _internal_size();
}
inline void AABB::unsafe_arena_set_allocated_size(
    ::wire::Vector3* size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.AABB.size)
}
inline ::wire::Vector3* AABB::release_size() {
  
  ::wire::Vector3* temp = size_;
  size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector3* AABB::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:wire.AABB.size)
  
  ::wire::Vector3* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::wire::Vector3* AABB::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector3>(GetArena());
    size_ = p;
  }
  return size_;
}
inline ::wire::Vector3* AABB::mutable_size() {
  // @@protoc_insertion_point(field_mutable:wire.AABB.size)
  return _internal_mutable_size();
}
inline void AABB::set_allocated_size(::wire::Vector3* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:wire.AABB.size)
}

// -------------------------------------------------------------------

// Basis

// .wire.Vector3 x = 1;
inline bool Basis::_internal_has_x() const {
  return this != internal_default_instance() && x_ != nullptr;
}
inline bool Basis::has_x() const {
  return _internal_has_x();
}
inline void Basis::clear_x() {
  if (GetArena() == nullptr && x_ != nullptr) {
    delete x_;
  }
  x_ = nullptr;
}
inline const ::wire::Vector3& Basis::_internal_x() const {
  const ::wire::Vector3* p = x_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector3*>(
      &::wire::_Vector3_default_instance_);
}
inline const ::wire::Vector3& Basis::x() const {
  // @@protoc_insertion_point(field_get:wire.Basis.x)
  return _internal_x();
}
inline void Basis::unsafe_arena_set_allocated_x(
    ::wire::Vector3* x) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  x_ = x;
  if (x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Basis.x)
}
inline ::wire::Vector3* Basis::release_x() {
  
  ::wire::Vector3* temp = x_;
  x_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector3* Basis::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:wire.Basis.x)
  
  ::wire::Vector3* temp = x_;
  x_ = nullptr;
  return temp;
}
inline ::wire::Vector3* Basis::_internal_mutable_x() {
  
  if (x_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector3>(GetArena());
    x_ = p;
  }
  return x_;
}
inline ::wire::Vector3* Basis::mutable_x() {
  // @@protoc_insertion_point(field_mutable:wire.Basis.x)
  return _internal_mutable_x();
}
inline void Basis::set_allocated_x(::wire::Vector3* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete x_;
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(x);
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:wire.Basis.x)
}

// .wire.Vector3 y = 2;
inline bool Basis::_internal_has_y() const {
  return this != internal_default_instance() && y_ != nullptr;
}
inline bool Basis::has_y() const {
  return _internal_has_y();
}
inline void Basis::clear_y() {
  if (GetArena() == nullptr && y_ != nullptr) {
    delete y_;
  }
  y_ = nullptr;
}
inline const ::wire::Vector3& Basis::_internal_y() const {
  const ::wire::Vector3* p = y_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector3*>(
      &::wire::_Vector3_default_instance_);
}
inline const ::wire::Vector3& Basis::y() const {
  // @@protoc_insertion_point(field_get:wire.Basis.y)
  return _internal_y();
}
inline void Basis::unsafe_arena_set_allocated_y(
    ::wire::Vector3* y) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Basis.y)
}
inline ::wire::Vector3* Basis::release_y() {
  
  ::wire::Vector3* temp = y_;
  y_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector3* Basis::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:wire.Basis.y)
  
  ::wire::Vector3* temp = y_;
  y_ = nullptr;
  return temp;
}
inline ::wire::Vector3* Basis::_internal_mutable_y() {
  
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector3>(GetArena());
    y_ = p;
  }
  return y_;
}
inline ::wire::Vector3* Basis::mutable_y() {
  // @@protoc_insertion_point(field_mutable:wire.Basis.y)
  return _internal_mutable_y();
}
inline void Basis::set_allocated_y(::wire::Vector3* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete y_;
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(y);
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:wire.Basis.y)
}

// .wire.Vector3 z = 3;
inline bool Basis::_internal_has_z() const {
  return this != internal_default_instance() && z_ != nullptr;
}
inline bool Basis::has_z() const {
  return _internal_has_z();
}
inline void Basis::clear_z() {
  if (GetArena() == nullptr && z_ != nullptr) {
    delete z_;
  }
  z_ = nullptr;
}
inline const ::wire::Vector3& Basis::_internal_z() const {
  const ::wire::Vector3* p = z_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector3*>(
      &::wire::_Vector3_default_instance_);
}
inline const ::wire::Vector3& Basis::z() const {
  // @@protoc_insertion_point(field_get:wire.Basis.z)
  return _internal_z();
}
inline void Basis::unsafe_arena_set_allocated_z(
    ::wire::Vector3* z) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z_);
  }
  z_ = z;
  if (z) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Basis.z)
}
inline ::wire::Vector3* Basis::release_z() {
  
  ::wire::Vector3* temp = z_;
  z_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector3* Basis::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_release:wire.Basis.z)
  
  ::wire::Vector3* temp = z_;
  z_ = nullptr;
  return temp;
}
inline ::wire::Vector3* Basis::_internal_mutable_z() {
  
  if (z_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector3>(GetArena());
    z_ = p;
  }
  return z_;
}
inline ::wire::Vector3* Basis::mutable_z() {
  // @@protoc_insertion_point(field_mutable:wire.Basis.z)
  return _internal_mutable_z();
}
inline void Basis::set_allocated_z(::wire::Vector3* z) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete z_;
  }
  if (z) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(z);
    if (message_arena != submessage_arena) {
      z = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    
  } else {
    
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:wire.Basis.z)
}

// -------------------------------------------------------------------

// Transform

// .wire.Basis basis = 1;
inline bool Transform::_internal_has_basis() const {
  return this != internal_default_instance() && basis_ != nullptr;
}
inline bool Transform::has_basis() const {
  return _internal_has_basis();
}
inline void Transform::clear_basis() {
  if (GetArena() == nullptr && basis_ != nullptr) {
    delete basis_;
  }
  basis_ = nullptr;
}
inline const ::wire::Basis& Transform::_internal_basis() const {
  const ::wire::Basis* p = basis_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Basis*>(
      &::wire::_Basis_default_instance_);
}
inline const ::wire::Basis& Transform::basis() const {
  // @@protoc_insertion_point(field_get:wire.Transform.basis)
  return _internal_basis();
}
inline void Transform::unsafe_arena_set_allocated_basis(
    ::wire::Basis* basis) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basis_);
  }
  basis_ = basis;
  if (basis) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Transform.basis)
}
inline ::wire::Basis* Transform::release_basis() {
  
  ::wire::Basis* temp = basis_;
  basis_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Basis* Transform::unsafe_arena_release_basis() {
  // @@protoc_insertion_point(field_release:wire.Transform.basis)
  
  ::wire::Basis* temp = basis_;
  basis_ = nullptr;
  return temp;
}
inline ::wire::Basis* Transform::_internal_mutable_basis() {
  
  if (basis_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Basis>(GetArena());
    basis_ = p;
  }
  return basis_;
}
inline ::wire::Basis* Transform::mutable_basis() {
  // @@protoc_insertion_point(field_mutable:wire.Transform.basis)
  return _internal_mutable_basis();
}
inline void Transform::set_allocated_basis(::wire::Basis* basis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete basis_;
  }
  if (basis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(basis);
    if (message_arena != submessage_arena) {
      basis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basis, submessage_arena);
    }
    
  } else {
    
  }
  basis_ = basis;
  // @@protoc_insertion_point(field_set_allocated:wire.Transform.basis)
}

// .wire.Vector3 origin = 2;
inline bool Transform::_internal_has_origin() const {
  return this != internal_default_instance() && origin_ != nullptr;
}
inline bool Transform::has_origin() const {
  return _internal_has_origin();
}
inline void Transform::clear_origin() {
  if (GetArena() == nullptr && origin_ != nullptr) {
    delete origin_;
  }
  origin_ = nullptr;
}
inline const ::wire::Vector3& Transform::_internal_origin() const {
  const ::wire::Vector3* p = origin_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Vector3*>(
      &::wire::_Vector3_default_instance_);
}
inline const ::wire::Vector3& Transform::origin() const {
  // @@protoc_insertion_point(field_get:wire.Transform.origin)
  return _internal_origin();
}
inline void Transform::unsafe_arena_set_allocated_origin(
    ::wire::Vector3* origin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(origin_);
  }
  origin_ = origin;
  if (origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Transform.origin)
}
inline ::wire::Vector3* Transform::release_origin() {
  
  ::wire::Vector3* temp = origin_;
  origin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Vector3* Transform::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:wire.Transform.origin)
  
  ::wire::Vector3* temp = origin_;
  origin_ = nullptr;
  return temp;
}
inline ::wire::Vector3* Transform::_internal_mutable_origin() {
  
  if (origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Vector3>(GetArena());
    origin_ = p;
  }
  return origin_;
}
inline ::wire::Vector3* Transform::mutable_origin() {
  // @@protoc_insertion_point(field_mutable:wire.Transform.origin)
  return _internal_mutable_origin();
}
inline void Transform::set_allocated_origin(::wire::Vector3* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(origin);
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    
  } else {
    
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:wire.Transform.origin)
}

// -------------------------------------------------------------------

// VariantArray

// -------------------------------------------------------------------

// Object

// fixed64 ptr = 1;
inline void Object::clear_ptr() {
  ptr_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::_internal_ptr() const {
  return ptr_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::ptr() const {
  // @@protoc_insertion_point(field_get:wire.Object.ptr)
  return _internal_ptr();
}
inline void Object::_internal_set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  ptr_ = value;
}
inline void Object::set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ptr(value);
  // @@protoc_insertion_point(field_set:wire.Object.ptr)
}

// int32 engine_constructor_index = 2;
inline void Object::clear_engine_constructor_index() {
  engine_constructor_index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::_internal_engine_constructor_index() const {
  return engine_constructor_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::engine_constructor_index() const {
  // @@protoc_insertion_point(field_get:wire.Object.engine_constructor_index)
  return _internal_engine_constructor_index();
}
inline void Object::_internal_set_engine_constructor_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  engine_constructor_index_ = value;
}
inline void Object::set_engine_constructor_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_engine_constructor_index(value);
  // @@protoc_insertion_point(field_set:wire.Object.engine_constructor_index)
}

// bool is_ref = 3;
inline void Object::clear_is_ref() {
  is_ref_ = false;
}
inline bool Object::_internal_is_ref() const {
  return is_ref_;
}
inline bool Object::is_ref() const {
  // @@protoc_insertion_point(field_get:wire.Object.is_ref)
  return _internal_is_ref();
}
inline void Object::_internal_set_is_ref(bool value) {
  
  is_ref_ = value;
}
inline void Object::set_is_ref(bool value) {
  _internal_set_is_ref(value);
  // @@protoc_insertion_point(field_set:wire.Object.is_ref)
}

// uint64 instance_id = 4;
inline void Object::clear_instance_id() {
  instance_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::_internal_instance_id() const {
  return instance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::instance_id() const {
  // @@protoc_insertion_point(field_get:wire.Object.instance_id)
  return _internal_instance_id();
}
inline void Object::_internal_set_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  instance_id_ = value;
}
inline void Object::set_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_instance_id(value);
  // @@protoc_insertion_point(field_set:wire.Object.instance_id)
}

// -------------------------------------------------------------------

// Value

// int32 nil_value = 1;
inline bool Value::_internal_has_nil_value() const {
  return type_case() == kNilValue;
}
inline void Value::set_has_nil_value() {
  _oneof_case_[0] = kNilValue;
}
inline void Value::clear_nil_value() {
  if (_internal_has_nil_value()) {
    type_.nil_value_ = 0;
    clear_has_type();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Value::_internal_nil_value() const {
  if (_internal_has_nil_value()) {
    return type_.nil_value_;
  }
  return 0;
}
inline void Value::_internal_set_nil_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!_internal_has_nil_value()) {
    clear_type();
    set_has_nil_value();
  }
  type_.nil_value_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Value::nil_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.nil_value)
  return _internal_nil_value();
}
inline void Value::set_nil_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nil_value(value);
  // @@protoc_insertion_point(field_set:wire.Value.nil_value)
}

// bool bool_value = 2;
inline bool Value::_internal_has_bool_value() const {
  return type_case() == kBoolValue;
}
inline void Value::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void Value::clear_bool_value() {
  if (_internal_has_bool_value()) {
    type_.bool_value_ = false;
    clear_has_type();
  }
}
inline bool Value::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return type_.bool_value_;
  }
  return false;
}
inline void Value::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_type();
    set_has_bool_value();
  }
  type_.bool_value_ = value;
}
inline bool Value::bool_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.bool_value)
  return _internal_bool_value();
}
inline void Value::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:wire.Value.bool_value)
}

// int64 long_value = 3;
inline bool Value::_internal_has_long_value() const {
  return type_case() == kLongValue;
}
inline void Value::set_has_long_value() {
  _oneof_case_[0] = kLongValue;
}
inline void Value::clear_long_value() {
  if (_internal_has_long_value()) {
    type_.long_value_ = PROTOBUF_LONGLONG(0);
    clear_has_type();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Value::_internal_long_value() const {
  if (_internal_has_long_value()) {
    return type_.long_value_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Value::_internal_set_long_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_long_value()) {
    clear_type();
    set_has_long_value();
  }
  type_.long_value_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Value::long_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.long_value)
  return _internal_long_value();
}
inline void Value::set_long_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_long_value(value);
  // @@protoc_insertion_point(field_set:wire.Value.long_value)
}

// double real_value = 4;
inline bool Value::_internal_has_real_value() const {
  return type_case() == kRealValue;
}
inline void Value::set_has_real_value() {
  _oneof_case_[0] = kRealValue;
}
inline void Value::clear_real_value() {
  if (_internal_has_real_value()) {
    type_.real_value_ = 0;
    clear_has_type();
  }
}
inline double Value::_internal_real_value() const {
  if (_internal_has_real_value()) {
    return type_.real_value_;
  }
  return 0;
}
inline void Value::_internal_set_real_value(double value) {
  if (!_internal_has_real_value()) {
    clear_type();
    set_has_real_value();
  }
  type_.real_value_ = value;
}
inline double Value::real_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.real_value)
  return _internal_real_value();
}
inline void Value::set_real_value(double value) {
  _internal_set_real_value(value);
  // @@protoc_insertion_point(field_set:wire.Value.real_value)
}

// string string_value = 5;
inline bool Value::_internal_has_string_value() const {
  return type_case() == kStringValue;
}
inline void Value::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void Value::clear_string_value() {
  if (_internal_has_string_value()) {
    type_.string_value_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_type();
  }
}
inline const std::string& Value::string_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.string_value)
  return _internal_string_value();
}
inline void Value::set_string_value(const std::string& value) {
  _internal_set_string_value(value);
  // @@protoc_insertion_point(field_set:wire.Value.string_value)
}
inline std::string* Value::mutable_string_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.string_value)
  return _internal_mutable_string_value();
}
inline const std::string& Value::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return type_.string_value_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_type();
    set_has_string_value();
    type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.string_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Value::set_string_value(std::string&& value) {
  // @@protoc_insertion_point(field_set:wire.Value.string_value)
  if (!_internal_has_string_value()) {
    clear_type();
    set_has_string_value();
    type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.string_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:wire.Value.string_value)
}
inline void Value::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_string_value()) {
    clear_type();
    set_has_string_value();
    type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.string_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:wire.Value.string_value)
}
inline void Value::set_string_value(const char* value,
                             size_t size) {
  if (!_internal_has_string_value()) {
    clear_type();
    set_has_string_value();
    type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.string_value_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:wire.Value.string_value)
}
inline std::string* Value::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_type();
    set_has_string_value();
    type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return type_.string_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Value::release_string_value() {
  // @@protoc_insertion_point(field_release:wire.Value.string_value)
  if (_internal_has_string_value()) {
    clear_has_type();
    return type_.string_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_string_value(std::string* string_value) {
  if (has_type()) {
    clear_type();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    type_.string_value_.UnsafeSetDefault(string_value);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(string_value);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:wire.Value.string_value)
}

// .wire.Vector2 vector2_value = 6;
inline bool Value::_internal_has_vector2_value() const {
  return type_case() == kVector2Value;
}
inline bool Value::has_vector2_value() const {
  return _internal_has_vector2_value();
}
inline void Value::set_has_vector2_value() {
  _oneof_case_[0] = kVector2Value;
}
inline void Value::clear_vector2_value() {
  if (_internal_has_vector2_value()) {
    if (GetArena() == nullptr) {
      delete type_.vector2_value_;
    }
    clear_has_type();
  }
}
inline ::wire::Vector2* Value::release_vector2_value() {
  // @@protoc_insertion_point(field_release:wire.Value.vector2_value)
  if (_internal_has_vector2_value()) {
    clear_has_type();
      ::wire::Vector2* temp = type_.vector2_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.vector2_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::Vector2& Value::_internal_vector2_value() const {
  return _internal_has_vector2_value()
      ? *type_.vector2_value_
      : *reinterpret_cast< ::wire::Vector2*>(&::wire::_Vector2_default_instance_);
}
inline const ::wire::Vector2& Value::vector2_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.vector2_value)
  return _internal_vector2_value();
}
inline ::wire::Vector2* Value::unsafe_arena_release_vector2_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.vector2_value)
  if (_internal_has_vector2_value()) {
    clear_has_type();
    ::wire::Vector2* temp = type_.vector2_value_;
    type_.vector2_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_vector2_value(::wire::Vector2* vector2_value) {
  clear_type();
  if (vector2_value) {
    set_has_vector2_value();
    type_.vector2_value_ = vector2_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.vector2_value)
}
inline ::wire::Vector2* Value::_internal_mutable_vector2_value() {
  if (!_internal_has_vector2_value()) {
    clear_type();
    set_has_vector2_value();
    type_.vector2_value_ = CreateMaybeMessage< ::wire::Vector2 >(GetArena());
  }
  return type_.vector2_value_;
}
inline ::wire::Vector2* Value::mutable_vector2_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.vector2_value)
  return _internal_mutable_vector2_value();
}

// .wire.Rect2 rect2_value = 7;
inline bool Value::_internal_has_rect2_value() const {
  return type_case() == kRect2Value;
}
inline bool Value::has_rect2_value() const {
  return _internal_has_rect2_value();
}
inline void Value::set_has_rect2_value() {
  _oneof_case_[0] = kRect2Value;
}
inline void Value::clear_rect2_value() {
  if (_internal_has_rect2_value()) {
    if (GetArena() == nullptr) {
      delete type_.rect2_value_;
    }
    clear_has_type();
  }
}
inline ::wire::Rect2* Value::release_rect2_value() {
  // @@protoc_insertion_point(field_release:wire.Value.rect2_value)
  if (_internal_has_rect2_value()) {
    clear_has_type();
      ::wire::Rect2* temp = type_.rect2_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rect2_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::Rect2& Value::_internal_rect2_value() const {
  return _internal_has_rect2_value()
      ? *type_.rect2_value_
      : *reinterpret_cast< ::wire::Rect2*>(&::wire::_Rect2_default_instance_);
}
inline const ::wire::Rect2& Value::rect2_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.rect2_value)
  return _internal_rect2_value();
}
inline ::wire::Rect2* Value::unsafe_arena_release_rect2_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.rect2_value)
  if (_internal_has_rect2_value()) {
    clear_has_type();
    ::wire::Rect2* temp = type_.rect2_value_;
    type_.rect2_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_rect2_value(::wire::Rect2* rect2_value) {
  clear_type();
  if (rect2_value) {
    set_has_rect2_value();
    type_.rect2_value_ = rect2_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.rect2_value)
}
inline ::wire::Rect2* Value::_internal_mutable_rect2_value() {
  if (!_internal_has_rect2_value()) {
    clear_type();
    set_has_rect2_value();
    type_.rect2_value_ = CreateMaybeMessage< ::wire::Rect2 >(GetArena());
  }
  return type_.rect2_value_;
}
inline ::wire::Rect2* Value::mutable_rect2_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.rect2_value)
  return _internal_mutable_rect2_value();
}

// .wire.Vector3 vector3_value = 8;
inline bool Value::_internal_has_vector3_value() const {
  return type_case() == kVector3Value;
}
inline bool Value::has_vector3_value() const {
  return _internal_has_vector3_value();
}
inline void Value::set_has_vector3_value() {
  _oneof_case_[0] = kVector3Value;
}
inline void Value::clear_vector3_value() {
  if (_internal_has_vector3_value()) {
    if (GetArena() == nullptr) {
      delete type_.vector3_value_;
    }
    clear_has_type();
  }
}
inline ::wire::Vector3* Value::release_vector3_value() {
  // @@protoc_insertion_point(field_release:wire.Value.vector3_value)
  if (_internal_has_vector3_value()) {
    clear_has_type();
      ::wire::Vector3* temp = type_.vector3_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.vector3_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::Vector3& Value::_internal_vector3_value() const {
  return _internal_has_vector3_value()
      ? *type_.vector3_value_
      : *reinterpret_cast< ::wire::Vector3*>(&::wire::_Vector3_default_instance_);
}
inline const ::wire::Vector3& Value::vector3_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.vector3_value)
  return _internal_vector3_value();
}
inline ::wire::Vector3* Value::unsafe_arena_release_vector3_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.vector3_value)
  if (_internal_has_vector3_value()) {
    clear_has_type();
    ::wire::Vector3* temp = type_.vector3_value_;
    type_.vector3_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_vector3_value(::wire::Vector3* vector3_value) {
  clear_type();
  if (vector3_value) {
    set_has_vector3_value();
    type_.vector3_value_ = vector3_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.vector3_value)
}
inline ::wire::Vector3* Value::_internal_mutable_vector3_value() {
  if (!_internal_has_vector3_value()) {
    clear_type();
    set_has_vector3_value();
    type_.vector3_value_ = CreateMaybeMessage< ::wire::Vector3 >(GetArena());
  }
  return type_.vector3_value_;
}
inline ::wire::Vector3* Value::mutable_vector3_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.vector3_value)
  return _internal_mutable_vector3_value();
}

// .wire.Transform2D transform2D_value = 9;
inline bool Value::_internal_has_transform2d_value() const {
  return type_case() == kTransform2DValue;
}
inline bool Value::has_transform2d_value() const {
  return _internal_has_transform2d_value();
}
inline void Value::set_has_transform2d_value() {
  _oneof_case_[0] = kTransform2DValue;
}
inline void Value::clear_transform2d_value() {
  if (_internal_has_transform2d_value()) {
    if (GetArena() == nullptr) {
      delete type_.transform2d_value_;
    }
    clear_has_type();
  }
}
inline ::wire::Transform2D* Value::release_transform2d_value() {
  // @@protoc_insertion_point(field_release:wire.Value.transform2D_value)
  if (_internal_has_transform2d_value()) {
    clear_has_type();
      ::wire::Transform2D* temp = type_.transform2d_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.transform2d_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::Transform2D& Value::_internal_transform2d_value() const {
  return _internal_has_transform2d_value()
      ? *type_.transform2d_value_
      : *reinterpret_cast< ::wire::Transform2D*>(&::wire::_Transform2D_default_instance_);
}
inline const ::wire::Transform2D& Value::transform2d_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.transform2D_value)
  return _internal_transform2d_value();
}
inline ::wire::Transform2D* Value::unsafe_arena_release_transform2d_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.transform2D_value)
  if (_internal_has_transform2d_value()) {
    clear_has_type();
    ::wire::Transform2D* temp = type_.transform2d_value_;
    type_.transform2d_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_transform2d_value(::wire::Transform2D* transform2d_value) {
  clear_type();
  if (transform2d_value) {
    set_has_transform2d_value();
    type_.transform2d_value_ = transform2d_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.transform2D_value)
}
inline ::wire::Transform2D* Value::_internal_mutable_transform2d_value() {
  if (!_internal_has_transform2d_value()) {
    clear_type();
    set_has_transform2d_value();
    type_.transform2d_value_ = CreateMaybeMessage< ::wire::Transform2D >(GetArena());
  }
  return type_.transform2d_value_;
}
inline ::wire::Transform2D* Value::mutable_transform2d_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.transform2D_value)
  return _internal_mutable_transform2d_value();
}

// .wire.Plane plane_value = 10;
inline bool Value::_internal_has_plane_value() const {
  return type_case() == kPlaneValue;
}
inline bool Value::has_plane_value() const {
  return _internal_has_plane_value();
}
inline void Value::set_has_plane_value() {
  _oneof_case_[0] = kPlaneValue;
}
inline void Value::clear_plane_value() {
  if (_internal_has_plane_value()) {
    if (GetArena() == nullptr) {
      delete type_.plane_value_;
    }
    clear_has_type();
  }
}
inline ::wire::Plane* Value::release_plane_value() {
  // @@protoc_insertion_point(field_release:wire.Value.plane_value)
  if (_internal_has_plane_value()) {
    clear_has_type();
      ::wire::Plane* temp = type_.plane_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.plane_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::Plane& Value::_internal_plane_value() const {
  return _internal_has_plane_value()
      ? *type_.plane_value_
      : *reinterpret_cast< ::wire::Plane*>(&::wire::_Plane_default_instance_);
}
inline const ::wire::Plane& Value::plane_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.plane_value)
  return _internal_plane_value();
}
inline ::wire::Plane* Value::unsafe_arena_release_plane_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.plane_value)
  if (_internal_has_plane_value()) {
    clear_has_type();
    ::wire::Plane* temp = type_.plane_value_;
    type_.plane_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_plane_value(::wire::Plane* plane_value) {
  clear_type();
  if (plane_value) {
    set_has_plane_value();
    type_.plane_value_ = plane_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.plane_value)
}
inline ::wire::Plane* Value::_internal_mutable_plane_value() {
  if (!_internal_has_plane_value()) {
    clear_type();
    set_has_plane_value();
    type_.plane_value_ = CreateMaybeMessage< ::wire::Plane >(GetArena());
  }
  return type_.plane_value_;
}
inline ::wire::Plane* Value::mutable_plane_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.plane_value)
  return _internal_mutable_plane_value();
}

// .wire.Quat quat_value = 11;
inline bool Value::_internal_has_quat_value() const {
  return type_case() == kQuatValue;
}
inline bool Value::has_quat_value() const {
  return _internal_has_quat_value();
}
inline void Value::set_has_quat_value() {
  _oneof_case_[0] = kQuatValue;
}
inline void Value::clear_quat_value() {
  if (_internal_has_quat_value()) {
    if (GetArena() == nullptr) {
      delete type_.quat_value_;
    }
    clear_has_type();
  }
}
inline ::wire::Quat* Value::release_quat_value() {
  // @@protoc_insertion_point(field_release:wire.Value.quat_value)
  if (_internal_has_quat_value()) {
    clear_has_type();
      ::wire::Quat* temp = type_.quat_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.quat_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::Quat& Value::_internal_quat_value() const {
  return _internal_has_quat_value()
      ? *type_.quat_value_
      : *reinterpret_cast< ::wire::Quat*>(&::wire::_Quat_default_instance_);
}
inline const ::wire::Quat& Value::quat_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.quat_value)
  return _internal_quat_value();
}
inline ::wire::Quat* Value::unsafe_arena_release_quat_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.quat_value)
  if (_internal_has_quat_value()) {
    clear_has_type();
    ::wire::Quat* temp = type_.quat_value_;
    type_.quat_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_quat_value(::wire::Quat* quat_value) {
  clear_type();
  if (quat_value) {
    set_has_quat_value();
    type_.quat_value_ = quat_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.quat_value)
}
inline ::wire::Quat* Value::_internal_mutable_quat_value() {
  if (!_internal_has_quat_value()) {
    clear_type();
    set_has_quat_value();
    type_.quat_value_ = CreateMaybeMessage< ::wire::Quat >(GetArena());
  }
  return type_.quat_value_;
}
inline ::wire::Quat* Value::mutable_quat_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.quat_value)
  return _internal_mutable_quat_value();
}

// .wire.AABB aabb_value = 12;
inline bool Value::_internal_has_aabb_value() const {
  return type_case() == kAabbValue;
}
inline bool Value::has_aabb_value() const {
  return _internal_has_aabb_value();
}
inline void Value::set_has_aabb_value() {
  _oneof_case_[0] = kAabbValue;
}
inline void Value::clear_aabb_value() {
  if (_internal_has_aabb_value()) {
    if (GetArena() == nullptr) {
      delete type_.aabb_value_;
    }
    clear_has_type();
  }
}
inline ::wire::AABB* Value::release_aabb_value() {
  // @@protoc_insertion_point(field_release:wire.Value.aabb_value)
  if (_internal_has_aabb_value()) {
    clear_has_type();
      ::wire::AABB* temp = type_.aabb_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.aabb_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::AABB& Value::_internal_aabb_value() const {
  return _internal_has_aabb_value()
      ? *type_.aabb_value_
      : *reinterpret_cast< ::wire::AABB*>(&::wire::_AABB_default_instance_);
}
inline const ::wire::AABB& Value::aabb_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.aabb_value)
  return _internal_aabb_value();
}
inline ::wire::AABB* Value::unsafe_arena_release_aabb_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.aabb_value)
  if (_internal_has_aabb_value()) {
    clear_has_type();
    ::wire::AABB* temp = type_.aabb_value_;
    type_.aabb_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_aabb_value(::wire::AABB* aabb_value) {
  clear_type();
  if (aabb_value) {
    set_has_aabb_value();
    type_.aabb_value_ = aabb_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.aabb_value)
}
inline ::wire::AABB* Value::_internal_mutable_aabb_value() {
  if (!_internal_has_aabb_value()) {
    clear_type();
    set_has_aabb_value();
    type_.aabb_value_ = CreateMaybeMessage< ::wire::AABB >(GetArena());
  }
  return type_.aabb_value_;
}
inline ::wire::AABB* Value::mutable_aabb_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.aabb_value)
  return _internal_mutable_aabb_value();
}

// .wire.Basis basis_value = 13;
inline bool Value::_internal_has_basis_value() const {
  return type_case() == kBasisValue;
}
inline bool Value::has_basis_value() const {
  return _internal_has_basis_value();
}
inline void Value::set_has_basis_value() {
  _oneof_case_[0] = kBasisValue;
}
inline void Value::clear_basis_value() {
  if (_internal_has_basis_value()) {
    if (GetArena() == nullptr) {
      delete type_.basis_value_;
    }
    clear_has_type();
  }
}
inline ::wire::Basis* Value::release_basis_value() {
  // @@protoc_insertion_point(field_release:wire.Value.basis_value)
  if (_internal_has_basis_value()) {
    clear_has_type();
      ::wire::Basis* temp = type_.basis_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.basis_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::Basis& Value::_internal_basis_value() const {
  return _internal_has_basis_value()
      ? *type_.basis_value_
      : *reinterpret_cast< ::wire::Basis*>(&::wire::_Basis_default_instance_);
}
inline const ::wire::Basis& Value::basis_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.basis_value)
  return _internal_basis_value();
}
inline ::wire::Basis* Value::unsafe_arena_release_basis_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.basis_value)
  if (_internal_has_basis_value()) {
    clear_has_type();
    ::wire::Basis* temp = type_.basis_value_;
    type_.basis_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_basis_value(::wire::Basis* basis_value) {
  clear_type();
  if (basis_value) {
    set_has_basis_value();
    type_.basis_value_ = basis_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.basis_value)
}
inline ::wire::Basis* Value::_internal_mutable_basis_value() {
  if (!_internal_has_basis_value()) {
    clear_type();
    set_has_basis_value();
    type_.basis_value_ = CreateMaybeMessage< ::wire::Basis >(GetArena());
  }
  return type_.basis_value_;
}
inline ::wire::Basis* Value::mutable_basis_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.basis_value)
  return _internal_mutable_basis_value();
}

// .wire.Transform transform_value = 14;
inline bool Value::_internal_has_transform_value() const {
  return type_case() == kTransformValue;
}
inline bool Value::has_transform_value() const {
  return _internal_has_transform_value();
}
inline void Value::set_has_transform_value() {
  _oneof_case_[0] = kTransformValue;
}
inline void Value::clear_transform_value() {
  if (_internal_has_transform_value()) {
    if (GetArena() == nullptr) {
      delete type_.transform_value_;
    }
    clear_has_type();
  }
}
inline ::wire::Transform* Value::release_transform_value() {
  // @@protoc_insertion_point(field_release:wire.Value.transform_value)
  if (_internal_has_transform_value()) {
    clear_has_type();
      ::wire::Transform* temp = type_.transform_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.transform_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::Transform& Value::_internal_transform_value() const {
  return _internal_has_transform_value()
      ? *type_.transform_value_
      : *reinterpret_cast< ::wire::Transform*>(&::wire::_Transform_default_instance_);
}
inline const ::wire::Transform& Value::transform_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.transform_value)
  return _internal_transform_value();
}
inline ::wire::Transform* Value::unsafe_arena_release_transform_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.transform_value)
  if (_internal_has_transform_value()) {
    clear_has_type();
    ::wire::Transform* temp = type_.transform_value_;
    type_.transform_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_transform_value(::wire::Transform* transform_value) {
  clear_type();
  if (transform_value) {
    set_has_transform_value();
    type_.transform_value_ = transform_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.transform_value)
}
inline ::wire::Transform* Value::_internal_mutable_transform_value() {
  if (!_internal_has_transform_value()) {
    clear_type();
    set_has_transform_value();
    type_.transform_value_ = CreateMaybeMessage< ::wire::Transform >(GetArena());
  }
  return type_.transform_value_;
}
inline ::wire::Transform* Value::mutable_transform_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.transform_value)
  return _internal_mutable_transform_value();
}

// .wire.VariantArray variant_array_value = 15;
inline bool Value::_internal_has_variant_array_value() const {
  return type_case() == kVariantArrayValue;
}
inline bool Value::has_variant_array_value() const {
  return _internal_has_variant_array_value();
}
inline void Value::set_has_variant_array_value() {
  _oneof_case_[0] = kVariantArrayValue;
}
inline void Value::clear_variant_array_value() {
  if (_internal_has_variant_array_value()) {
    if (GetArena() == nullptr) {
      delete type_.variant_array_value_;
    }
    clear_has_type();
  }
}
inline ::wire::VariantArray* Value::release_variant_array_value() {
  // @@protoc_insertion_point(field_release:wire.Value.variant_array_value)
  if (_internal_has_variant_array_value()) {
    clear_has_type();
      ::wire::VariantArray* temp = type_.variant_array_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.variant_array_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::VariantArray& Value::_internal_variant_array_value() const {
  return _internal_has_variant_array_value()
      ? *type_.variant_array_value_
      : *reinterpret_cast< ::wire::VariantArray*>(&::wire::_VariantArray_default_instance_);
}
inline const ::wire::VariantArray& Value::variant_array_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.variant_array_value)
  return _internal_variant_array_value();
}
inline ::wire::VariantArray* Value::unsafe_arena_release_variant_array_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.variant_array_value)
  if (_internal_has_variant_array_value()) {
    clear_has_type();
    ::wire::VariantArray* temp = type_.variant_array_value_;
    type_.variant_array_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_variant_array_value(::wire::VariantArray* variant_array_value) {
  clear_type();
  if (variant_array_value) {
    set_has_variant_array_value();
    type_.variant_array_value_ = variant_array_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.variant_array_value)
}
inline ::wire::VariantArray* Value::_internal_mutable_variant_array_value() {
  if (!_internal_has_variant_array_value()) {
    clear_type();
    set_has_variant_array_value();
    type_.variant_array_value_ = CreateMaybeMessage< ::wire::VariantArray >(GetArena());
  }
  return type_.variant_array_value_;
}
inline ::wire::VariantArray* Value::mutable_variant_array_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.variant_array_value)
  return _internal_mutable_variant_array_value();
}

// .wire.Object object_value = 16;
inline bool Value::_internal_has_object_value() const {
  return type_case() == kObjectValue;
}
inline bool Value::has_object_value() const {
  return _internal_has_object_value();
}
inline void Value::set_has_object_value() {
  _oneof_case_[0] = kObjectValue;
}
inline void Value::clear_object_value() {
  if (_internal_has_object_value()) {
    if (GetArena() == nullptr) {
      delete type_.object_value_;
    }
    clear_has_type();
  }
}
inline ::wire::Object* Value::release_object_value() {
  // @@protoc_insertion_point(field_release:wire.Value.object_value)
  if (_internal_has_object_value()) {
    clear_has_type();
      ::wire::Object* temp = type_.object_value_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.object_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::wire::Object& Value::_internal_object_value() const {
  return _internal_has_object_value()
      ? *type_.object_value_
      : *reinterpret_cast< ::wire::Object*>(&::wire::_Object_default_instance_);
}
inline const ::wire::Object& Value::object_value() const {
  // @@protoc_insertion_point(field_get:wire.Value.object_value)
  return _internal_object_value();
}
inline ::wire::Object* Value::unsafe_arena_release_object_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:wire.Value.object_value)
  if (_internal_has_object_value()) {
    clear_has_type();
    ::wire::Object* temp = type_.object_value_;
    type_.object_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_object_value(::wire::Object* object_value) {
  clear_type();
  if (object_value) {
    set_has_object_value();
    type_.object_value_ = object_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.Value.object_value)
}
inline ::wire::Object* Value::_internal_mutable_object_value() {
  if (!_internal_has_object_value()) {
    clear_type();
    set_has_object_value();
    type_.object_value_ = CreateMaybeMessage< ::wire::Object >(GetArena());
  }
  return type_.object_value_;
}
inline ::wire::Object* Value::mutable_object_value() {
  // @@protoc_insertion_point(field_mutable:wire.Value.object_value)
  return _internal_mutable_object_value();
}

inline bool Value::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Value::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Value::TypeCase Value::type_case() const {
  return Value::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ReturnValue

// .wire.Value data = 1;
inline bool ReturnValue::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool ReturnValue::has_data() const {
  return _internal_has_data();
}
inline void ReturnValue::clear_data() {
  if (GetArena() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::wire::Value& ReturnValue::_internal_data() const {
  const ::wire::Value* p = data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::wire::Value*>(
      &::wire::_Value_default_instance_);
}
inline const ::wire::Value& ReturnValue::data() const {
  // @@protoc_insertion_point(field_get:wire.ReturnValue.data)
  return _internal_data();
}
inline void ReturnValue::unsafe_arena_set_allocated_data(
    ::wire::Value* data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:wire.ReturnValue.data)
}
inline ::wire::Value* ReturnValue::release_data() {
  
  ::wire::Value* temp = data_;
  data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::wire::Value* ReturnValue::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:wire.ReturnValue.data)
  
  ::wire::Value* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::wire::Value* ReturnValue::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::wire::Value>(GetArena());
    data_ = p;
  }
  return data_;
}
inline ::wire::Value* ReturnValue::mutable_data() {
  // @@protoc_insertion_point(field_mutable:wire.ReturnValue.data)
  return _internal_mutable_data();
}
inline void ReturnValue::set_allocated_data(::wire::Value* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:wire.ReturnValue.data)
}

// -------------------------------------------------------------------

// FuncArgs

// repeated .wire.Value args = 1;
inline int FuncArgs::_internal_args_size() const {
  return args_.size();
}
inline int FuncArgs::args_size() const {
  return _internal_args_size();
}
inline void FuncArgs::clear_args() {
  args_.Clear();
}
inline ::wire::Value* FuncArgs::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:wire.FuncArgs.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::wire::Value >*
FuncArgs::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:wire.FuncArgs.args)
  return &args_;
}
inline const ::wire::Value& FuncArgs::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::wire::Value& FuncArgs::args(int index) const {
  // @@protoc_insertion_point(field_get:wire.FuncArgs.args)
  return _internal_args(index);
}
inline ::wire::Value* FuncArgs::_internal_add_args() {
  return args_.Add();
}
inline ::wire::Value* FuncArgs::add_args() {
  // @@protoc_insertion_point(field_add:wire.FuncArgs.args)
  return _internal_add_args();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::wire::Value >&
FuncArgs::args() const {
  // @@protoc_insertion_point(field_list:wire.FuncArgs.args)
  return args_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace wire

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_wire_2eproto
